package ego

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"strings"
	"unicode"
)

// Template represents an entire Ego template.
// A template consists of zero or more blocks.
// Blocks can be either a TextBlock, a PrintBlock, a RawPrintBlock, or a CodeBlock.
type Template struct {
	Path   string
	Blocks []Block
}

// WriteTo writes the template to a writer.
func (t *Template) WriteTo(w io.Writer) (n int64, err error) {
	var buf bytes.Buffer

	// Write "generated" header comment.
	buf.WriteString("// Generated by ego.\n")
	buf.WriteString("// DO NOT EDIT\n\n")

	// Write blocks.
	for _, blk := range t.Blocks {
		// Write line comment.
		if pos := blk.BlockPos(); pos.Path != "" && pos.LineNo > 0 {
			nn, err := fmt.Fprintf(&buf, "//line %s:%d\n", pos.Path, pos.LineNo)
			if n += int64(nn); err != nil {
				return n, err
			}
		}

		// Write block.
		switch blk := blk.(type) {
		case *TextBlock:
			nn, err := fmt.Fprintf(&buf, `_, _ = io.WriteString(w, %q)`+"\n", blk.Content)
			if n += int64(nn); err != nil {
				return n, err
			}

		case *CodeBlock:
			nn, err := fmt.Fprintln(&buf, blk.Content)
			if n += int64(nn); err != nil {
				return n, err
			}

		case *PrintBlock:
			nn, err := fmt.Fprintf(&buf, `_, _ = io.WriteString(w, html.EscapeString(fmt.Sprint(%s)))`+"\n", blk.Content)
			if n += int64(nn); err != nil {
				return n, err
			}

		case *RawPrintBlock:
			nn, err := fmt.Fprintf(&buf, `_, _ = fmt.Fprint(w, %s)`+"\n", blk.Content)
			if n += int64(nn); err != nil {
				return n, err
			}
		}
	}

	// Parse buffer as a Go file.
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, "", buf.Bytes(), parser.ParseComments)
	if err != nil {
		n, _ = buf.WriteTo(w)
		return n, err
	}

	// Inject required packages.
	injectImports(f)

	// Attempt to gofmt.
	var result bytes.Buffer
	if err := format.Node(&result, fset, f); err != nil {
		n, _ = buf.WriteTo(w)
		return n, err
	}

	// Write to output writer.
	return result.WriteTo(w)
}

// Normalize joins together adjacent text blocks.
func (t *Template) Normalize() {
	t.joinAdjacentTextBlocks()
	t.trimTrailingEmptyTextBlocks()
}

func (t *Template) joinAdjacentTextBlocks() {
	var a []Block
	var hasTextBlock bool
	for _, blk := range t.Blocks {
		curr, isTextBlock := blk.(*TextBlock)

		// Trim left space from the first text block. Discard empty blocks.
		if isTextBlock {
			if !hasTextBlock {
				curr.Content = strings.TrimLeftFunc(curr.Content, unicode.IsSpace)
			}
			if curr.Content == "" {
				continue
			}
			hasTextBlock = true
		}

		// Always append the first block.
		if len(a) == 0 {
			a = append(a, blk)
			continue
		}

		// Simply append if this block or prev block are not text blocks.
		prev, isPrevTextBlock := a[len(a)-1].(*TextBlock)
		if !isTextBlock || !isPrevTextBlock {
			a = append(a, blk)
			continue
		}

		// Append this text block's content to the previous block.
		prev.Content += curr.Content
	}

	t.Blocks = a
}

func (t *Template) trimTrailingEmptyTextBlocks() {
	for len(t.Blocks) > 0 {
		blk, ok := t.Blocks[len(t.Blocks)-1].(*TextBlock)
		if !ok || strings.TrimSpace(blk.Content) != "" {
			return
		}
		t.Blocks[len(t.Blocks)-1] = nil
		t.Blocks = t.Blocks[:len(t.Blocks)-1]
	}
}

func injectImports(f *ast.File) {
	names := []string{`"fmt"`, `"html"`, `"io"`}

	// Strip packages from existing imports.
	for i := 0; i < len(f.Decls); i++ {
		decl, ok := f.Decls[i].(*ast.GenDecl)
		if !ok || decl.Tok != token.IMPORT {
			continue
		}

		// Remove listed imports.
		removeImportSpecs(decl, names)

		// Remove declaration if it has no imports.
		if len(decl.Specs) == 0 {
			copy(f.Decls[i:], f.Decls[i+1:])
			f.Decls[len(f.Decls)-1] = nil
			f.Decls = f.Decls[:len(f.Decls)-1]
			i--
		}
	}

	// Generate new import.
	for i := len(names) - 1; i >= 0; i-- {
		f.Decls = append([]ast.Decl{&ast.GenDecl{
			Tok: token.IMPORT,
			Specs: []ast.Spec{
				&ast.ImportSpec{Path: &ast.BasicLit{Kind: token.STRING, Value: names[i]}},
			},
		}}, f.Decls...)
	}

	// Add unnamed vars at the end of the file to ensure imports are used.
	f.Decls = append(f.Decls, &ast.GenDecl{
		Tok: token.VAR,
		Specs: []ast.Spec{
			&ast.ValueSpec{Names: []*ast.Ident{{Name: "_"}}, Type: &ast.Ident{Name: "fmt.Stringer"}},
		},
	})
	f.Decls = append(f.Decls, &ast.GenDecl{
		Tok: token.VAR,
		Specs: []ast.Spec{
			&ast.ValueSpec{Names: []*ast.Ident{{Name: "_"}}, Type: &ast.Ident{Name: "io.Reader"}},
		},
	})
	f.Decls = append(f.Decls, &ast.GenDecl{
		Tok: token.VAR,
		Specs: []ast.Spec{
			&ast.ValueSpec{Names: []*ast.Ident{{Name: "_"}}, Values: []ast.Expr{&ast.Ident{Name: "html.EscapeString"}}},
		},
	})
}

func removeImportSpecs(decl *ast.GenDecl, names []string) {
	for i := 0; i < len(decl.Specs); i++ {
		spec, ok := decl.Specs[i].(*ast.ImportSpec)
		if !ok || !stringSliceContains(names, spec.Path.Value) {
			continue
		}

		// Delete spec.
		copy(decl.Specs[i:], decl.Specs[i+1:])
		decl.Specs[len(decl.Specs)-1] = nil
		decl.Specs = decl.Specs[:len(decl.Specs)-1]

		i--
	}
}

// Block represents an element of the template.
type Block interface {
	BlockPos() Pos
}

// TextBlock represents a UTF-8 encoded block of text that is written to the writer as-is.
type TextBlock struct {
	Pos     Pos
	Content string
}

// BlockPos returns the position for the block.
func (blk *TextBlock) BlockPos() Pos { return blk.Pos }

// CodeBlock represents a Go code block that is printed as-is to the template.
type CodeBlock struct {
	Pos     Pos
	Content string
}

// BlockPos returns the position for the block.
func (blk *CodeBlock) BlockPos() Pos { return blk.Pos }

// RawPrintBlock represents a block of the template that is printed out to the writer.
type RawPrintBlock struct {
	Pos     Pos
	Content string
}

// BlockPos returns the position for the block.
func (blk *RawPrintBlock) BlockPos() Pos { return blk.Pos }

// PrintBlock represents a block that will HTML escape the contents before outputting
type PrintBlock struct {
	Pos     Pos
	Content string
}

// BlockPos returns the position for the block.
func (blk *PrintBlock) BlockPos() Pos { return blk.Pos }

// Pos represents a position in a given file.
type Pos struct {
	Path   string
	LineNo int
}

func stringSliceContains(a []string, v string) bool {
	for i := range a {
		if a[i] == v {
			return true
		}
	}
	return false
}
